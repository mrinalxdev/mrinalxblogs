---
title: Build a custom memory allocator in go
date: '2024-12-9'
---

Writing your own memory allocator in go is just stupid !! Go already has the best memory allocator and garbage collector . Why to re-write this from scratch ?

Well as someone who believes in `talk is cheap show me the code` kind of quotes, I am diving deep into building this stuff from scratch using golang.

### What is a Memory Allocator ?

In simple words it organizes and manages the computer's memory, giving out chunks to program when they ask for it and taking them back when they're done, it keeps things smooth and chaos free for the computer to compute and execute the program.

### Types of Memory Allocator 

1. Stack Allocator : Utilizes a stack data structure for managing local variables and function call frames. It operates on a last-in, first-out (LIFO) basis, providing fast and deterministic allocation and deallocation

2. Heap Allocator : Manages a larger pool of memory known as the heap, allowing for dynamic allocations. Functions like `malloc()` and `free()` are commonly used in languages like C/C++

3. Buddy Allocator : Divides memory into fixed-size blocks that are powers of two. When a request is made, it splits larger blocks to satisfy the request and merges them when freed if their "buddy" block is also free
--- 


## We are building this up !!

At first we should decide what out program should contain and plan our way out (this is my way 🤓☝️)

#### Needed Data Structures for this implementation
- A data structure to represent a memory block

```go
type Block struct {
    Start int
    Size int
    Allocated bool
}
```

- Another data structure represent the memory pool

```go
type MemoryPool struct {
    Size int
    Blocks []Block
}
```

#### Focusing on the core functions

- Allocation `malloc`/`realloc` : Accepts a size request and returns a pointer to a momory block, to ensure the block is aligned to avoid performance panelaties or crashes

The allocate function is responsible for allocating a block of memory from the memory pool. This function takes a single argument, size, which represents the size of the memory block to be allocated.
The function returns two values: an **int** representing the starting address of the allocated memory block, and an **error** indicating whether the allocation was successful or not.

If the allocated block has remaining memory (i.e., its original size is greater than the requested size), the function creates a new free block to represent the remaining memory.

If the loop completes without finding a suitable free block, the function returns an error indicating that there is insufficient memory available.

```go
func allocate(size int) (int, error) {
	for i, block := range pool.Blocks {
		if block.Status == "Free" && block.Size >= size {
			pool.Blocks[i].Size = size
			pool.Blocks[i].Status = "Allocated"

			if block.Size > size {
				remaining := Block{
					Start:  block.Start + size,
					Size:   block.Size - size,
					Status: "Free",
				}
				pool.Blocks = append(pool.Blocks[:i+1], append([]Block{remaining}, pool.Blocks[i+1:]...)...)
			}
			return block.Start, nil
		}
	}
	return -1, fmt.Errorf("insufficient memory")
}
```

- DeAllocation `free` : the `free` function is reponsible for deallocation of a block of memory from the memory pool. This function takes a single argument, `start`, which represents the starting address of the block to be deallocated.
The sole functionality of this function is to iterate through the `pool.Blocks` slice, which contains a collection of memory blocks. Each block has a `Start` address, a `Status` (either 'Allocated' or 'Free'), and other relevant metadata.

```go
func free(start int) error {
	for i, block := range pool.Blocks {
		if block.Start == start && block.Status == "Allocated" {
			pool.Blocks[i].Status = "Free"
			mergeFreeBlocks()
			return nil
		}
	}
	return fmt.Errorf("no allocated block found at address %d", start)
}
```

- Merging `mergeFreeBlocks` : After deallocating the block, the function calls **mergeFreeBlocks()** to consolidate adjacent free blocks into a single, larger block. This helps to reduce fragmentation and improve memory utilization.

```go
func mergeFreeBlocks() {
	merged := []Block{}
	for _, block := range pool.Blocks {
		if len(merged) > 0 && merged[len(merged)-1].Status == "Free" && block.Status == "Free" {
			merged[len(merged)-1].Size += block.Size
		} else {
			merged = append(merged, block)
		}
	}
	pool.Blocks = merged
}
```

- Displaying the stats

```go
func memoryStats() {
	fmt.Printf("Memory Pool Size: %d bytes\n", pool.Size)
	fmt.Println("Blocks:")
	for _, block := range pool.Blocks {
		fmt.Printf("  Start: %d, Size: %d, Status: %s\n", block.Start, block.Size, block.Status)
	}
}
```

#### Here comes the CLI part
For the cli I have used ``github.com/spf13/cobra`` package to get more functionalities while building our CLI. Most of the CLI command were common and could be practise while building, explained it in the comments only

```go
func main() {
	// Initialize memory pool
	initMemoryPool(defaultSize)

	// Create root command
	rootCmd = &cobra.Command{
		Use:   "memalloc",
		Short: "Memory Allocator CLI",
		Run: func(cmd *cobra.Command, args []string) {
			fmt.Println("Memory Allocator CLI\n")
			fmt.Println(cmd.UsageString())
		},
	}

	// Define commands
	allocCmd = &cobra.Command{
		Use:   "alloc [size]",
		Short: "Allocate memory of a given size",
		Args:  cobra.ExactArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			size, err := strconv.Atoi(args[0])
			if err != nil {
				fmt.Println("Invalid size")
				return
			}
			addr, err := allocate(size)
			if err != nil {
				fmt.Println("Error:", err)
			} else {
				fmt.Printf("Allocated %d bytes at address %d\n", size, addr)
			}
		},
	}

	freeCmd = &cobra.Command{
		Use:   "free [start]",
		Short: "Free memory at a given address",
		Args:  cobra.ExactArgs(1),
		Run: func(cmd *cobra.Command, args []string) {
			start, err := strconv.Atoi(args[0])
			if err != nil {
				fmt.Println("Invalid address")
				return
			}
			if err := free(start); err != nil {
				fmt.Println("Error:", err)
			} else {
				fmt.Printf("Freed memory at address %d\n", start)
			}
		},
	}

	statsCmd = &cobra.Command{
		Use:   "stats",
		Short: "Display memory pool statistics",
		Run: func(cmd *cobra.Command, args []string) {
			memoryStats()
		},
	}

	// Add commands to root
	rootCmd.AddCommand(allocCmd, freeCmd, statsCmd)

	// Execute CLI
	if err := rootCmd.Execute(); err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	}
}
```

Here we have built a simple memory allocator using golang, the idea is pretty dumb to build this from scratch, but the more you build things from scratch the more in-depth you go for a topic. This project tests heavily on your memory management skills. 

Here is the Demo for the what we have built : [Demo]()